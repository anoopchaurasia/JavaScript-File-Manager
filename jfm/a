1,5d0
< /* 
<  * To change this template, choose Tools | Templates
<  * and open the template in the editor.
<  */
< 
10,11c5
< var fs = require('fs');
< t = new Date().getTime();
---
> 
13,41c7,8
< 	//this is master jfm
< 	// This method is adding a $add method into class prototype wchich is being
< 	// used to create setter and getter for its own property.
< 	function creareSetGet( classProto ) {
< 		// Storing key:value in separate variable as using original object will
< 		// create infinit loop.
< 		var valueStorage = {};
< 		// Static is not supported.... will not support ie < 9;
< 		// Adding setter and getter
< 		classProto.prototype.$add = function( obj, key, val, isConst ) {
< 			
< 			// val has a value for it's original object.
< 			if (val != undefined) {
< 				valueStorage[key] = val;
< 			}
< 			
< 			function setter( val ) {
< 				if (isConst) {
< 					throw this + "." + key + " can not be changed.";
< 				}
< 				valueStorage[key] = val;
< 			}
< 			
< 			function getter( ) {
< 				return valueStorage[key];
< 			}
< 			obj.__defineGetter__(key, getter);
< 			obj.__defineSetter__(key, setter);
< 		};
---
> 	if(window.fm && window.fm['package']){
> 		return ;
43d9
< 	
45,47c11,15
< 	if (!window.fm) {
< 		window.fm = {};
< 	}
---
> 	window.fm = {};
> 
> 	// currentScript is being used to contain all information of currently
> 	// loaded JavaScript file.
> 	var currentScript;
49,54c17,48
< 	
< 	window.fm.basedir = "/src/node";
< 	
< 	// /window.fm.import adds new javascript file to head of document. JAVA:
< 	// import
< 	window.fm['import'] = window.fm.Import = function Import( path ) {
---
> 
> 	fm.basedir = "/javascript";
> 
> 	// fm.stackTrace can be used to collect to print function stack;
> 	// JAVA:Exception.stacktrace
> 	fm.stackTrace = function( message ) {
> 		try {
> 			if (message) {
> 				console.error(message);
> 			}
> 			var a = arguments.callee, str = "";
> 			while (a.caller) {
> 				if (a.caller.getName) {
> 					str += a.caller.getName() + " of " + a.caller.$Class + "\n";
> 				}
> 				else if (a.caller.name != "") {
> 					str += a.caller.name + "\n";
> 				}
> 				a = a.caller;
> 			}
> 			console.log(str);
> 			var k = ty;
> 		}
> 		catch (e) {
> 			console.error(e.stack && e.stack.substring(e.stack.indexOf("\n")));
> 			// System.out.println(e.stack &&
> 			// e.stack.substring(e.stack.indexOf("\n")));
> 		}
> 	};
> 
> 	// /fm.import adds new javascript file to head of document. JAVA: import
> 	fm['import'] = fm.Import = function Import( path ) {
60c54
< 	
---
> 
63,68c57,67
< 	
< 	// /same as window.fm.import but for non jfm files.
< 	window.fm['include'] = window.fm.Include = function Include( path, data ) {
< 		var temp = fm.basedir.replace(/\//gim, "");
< 		if (!storePath[temp + path]) {
< 			storePath[temp + path] = true;
---
> 
> 	// /same as fm.import but for non jfm files.
> 	fm['include'] = fm.Include = function Include( ) {
> 		var args = [];
> 		for (var k =1; k < arguments.length; k++){
> 			args.push(arguments[k]);
> 		}
> 		var path = arguments[0];
> 		var temp = fm.basedir.replace(/\//gim,"");
> 		if (!storePath[temp+ path]) {
> 			storePath[temp + path] = args || true;
70a70,75
> 			if(typeof args[args.length -1] == 'function'){
> 				args.pop()();
> 			}
> 			return this;
> 		}
> 		if (fm.isConcatinated && path.indexOf("http") != 0) {
75c80,83
< 			path = window.fm.basedir + "/" + path.split(".").join("/") + ".js";
---
> 			path = fm.basedir + "/" + path.split(".").join("/") + ".js";
> 			if(fm.isMinified){
> 				path += "min.js";
> 			}
80,81c88,96
< 	
< 	
---
> 
> 	// /onReadyState method get called when browser fail to load a javascript
> 	// file.
> 	function onReadyState( ) {
> 		console.error("Unable to load file: " + this.src + ". Please check the file name and parh.");
> 		// fm.holdReady(false);
> 		return false;
> 	}
> 
85,86c100,101
< 		
< 		var script = scriptArr[scriptArr.length - 1];
---
> 		!currentScript && fm.Package();
> 		var script = currentScript;
97c112,113
< 	
---
> 	var docHead;
> 
99,117c115,131
< 	function include( path, data ) {
< 		scriptArr.push({
< 			packageName : ""
< 		});
< 		// delete Module._cache[path];
< 		require(path);
< 		
< //		fs.watchFile(path, {
< //		    persistent : true,
< //		    interval : 5000
< //		}, function( ) {
< //			scriptArr.push({
< //				packageName : ""
< //			});
< //			delete require.cache[path.replace(/\//g, '\\')];
< //			require(path);
< //			classManager(scriptArr.pop());
< //		});
< 		classManager(scriptArr.pop());
---
> 	function include( path ) {
> 		if (!docHead) {
> 			docHead = document.getElementsByTagName("head")[0];
> 		}
> 		// isNonfm && fm.holdReady(true);
> 		var e = document.createElement("script");
> 		// onerror is not supported by IE so this will throw exception only for
> 		// non IE browsers.
> 
> 		if(fm.version){
> 			path += "?v=" + fm.version;
> 		}
> 		e.onerror = onReadyState;
> 		e.src = path;
> 		e.type = "text/javascript";
> 		docHead.appendChild(e);
> 
119c133
< 	var scriptArr = [];
---
> 
121,123c135,136
< 	window.fm["package"] = window.fm.Package = function Package( packageName ) {
< 		scriptArr.pop();
< 		var script = {
---
> 	fm["package"] = fm.Package = function Package( packageName ) {
> 		currentScript = {
126d138
< 		scriptArr.push(script);
129c141
< 	
---
> 
131,133c143,144
< 	window.fm['super'] = window.fm['base'] = window.fm.Base = function Base( baseClass ) {
< 		var script = scriptArr[scriptArr.length - 1];
< 		script && (script.baseClass = baseClass) && this.Import(baseClass);
---
> 	fm['super'] = fm['base'] = fm.Base = function Base( baseClass ) {
> 		currentScript && (currentScript.baseClass = baseClass) && this.Import(baseClass);
136c147
< 	
---
> 
138,140c149,151
< 	window.fm["interface"] = window.fm.Interface = function Interface( ) {
< 		var script = scriptArr[scriptArr.length - 1];
< 		script.isInterface = true;
---
> 	fm["interface"] = fm.Interface = function Interface( ) {
> 		!currentScript && this.Package();
> 		currentScript.isInterface = true;
142d152
< 		
144,147c154,157
< 	
< 	window.fm['abstractClass'] = window.fm.AbstractClass = function( ) {
< 		var script = scriptArr[scriptArr.length - 1];
< 		script.isAbstract = true;
---
> 
> 	fm['abstractClass'] = fm.AbstractClass = function( ) {
> 		!currentScript && this.Package();
> 		currentScript.isAbstract = true;
152,154c162,164
< 	window.fm['implements'] = window.fm.Implements = function Implements( ) {
< 		
< 		var script = scriptArr[scriptArr.length - 1];
---
> 	fm['implements'] = fm.Implements = function Implements( ) {
> 		!currentScript && this.Package();
> 		var script = currentScript;
161,163d170
< 	
< 	// window.fm.Class creates a jfm class.
< 	window.fm['class'] = window.fm["Class"] = function Class( ){
165c172,191
< 		var script = scriptArr[scriptArr.length - 1];
---
> 	fm.isExist = function( cls ) {
> 		var s = cls.split(".");
> 		var o = window;
> 		for ( var k in s) {
> 			if (!o[s[k]]) {
> 				return false;
> 			}
> 			o = o[s[k]];
> 		}
> 
> 		if(typeof o == 'function'){
> 			return o;
> 		}
> 		return false;
> 	};
> 
> 	// fm.Class creates a jfm class.
> 	fm['class'] = fm["Class"] = function Class( ){
> 		!currentScript && this.Package();
> 		var script = currentScript, data;
172a199
> 
173a201,207
> 		var temp = fm.basedir.replace(/\//gim,"");
> 		if (typeof storePath[temp  + script.Class] == 'object') {
> 			data = storePath[temp  + script.Class];
> 			storePath[temp  + script.Class] = true;
> 		}
> 		callAfterDelay(script, data, o[script.className]);
> 		currentScript = undefined;
175,178c209,227
< 	
< 	// window.fm.stringToObject: map a string into object.
< 	window.fm.stringToObject = function stringToObject( classStr ) {
< 		var Class = window, classStrArr = classStr.split(".");
---
> 
> 	fm.globaltransient = [];
> 
> 	// callAfterDelay:Delay the call for classManager so that file get compiled
> 	// completely.
> 	// And classManager get all information about the function.
> 	function callAfterDelay( script, data,  older) {
> 		setTimeout(function( ) {
> 			// Calling classmanager after a short delay so that file get
> 			// completely ready.
> 			classManager(script, data, older);
> 			// fm.holdReady(false);
> 		});
> 	}
> 
> 
> 	// fm.stringToObject: map a string into object.
> 	fm.stringToObject = function stringToObject( classStr, Class ) {
> 		 Class = Class || window, classStrArr = classStr.split(".");
184c233
< 	
---
> 
197c246,348
< 	
---
> 
> 	// Contain all classses dependent on a class with className {id};
> 	// method to check if Object.defineProperty supported by browser.
> 	// IE8 support Object.defineProperty only for dom object.
> 	function doesDefinePropertyWork( object ) {
> 		try {
> 			Object.defineProperty(object, "a", {});
> 			return "a" in object;
> 		}
> 		catch (e) {
> 			return false;
> 		}
> 	}
> 
> 	if (!Function.prototype.bind) {
> 		Function.bind = Function.prototype.bind = function( obj ) {
> 			var thisFun = this;
> 			return function( ) {
> 				return thisFun.apply(obj, arguments);
> 			};
> 		};
> 	}
> 
> 	// Checking if setter and getter is supported by browser.
> 	var isGetterSetterSupported = doesDefinePropertyWork({}) || Object.prototype.__defineGetter__;
> 
> 	// This method is adding a $add method into class prototype wchich is being
> 	// used to create setter and getter for its own property.
> 	function creareSetGet( classProto ) {
> 		// Storing key:value in separate variable as using original object will
> 		// create infinit loop.
> 		var valueStorage = {};
> 		// Static is not supported.... will not support ie < 9;
> 		// Adding setter and getter
> 		classProto.prototype.$add = function( obj, key, val, isConst ) {
> 
> 			// val has a value for it's original object.
> 			if (val != undefined) {
> 				valueStorage[key] = val;
> 			}
> 
> 			function setter( newval ) {
> 				if (isConst) {
> 					throw this + "." + key + " can not be changed.";
> 				}
> 				valueStorage[key] = newval;
> 			}
> 
> 			function getter( ) {
> 				return valueStorage[key];
> 			}
> 			obj[key] = null;
> 			if (Object.defineProperty && isGetterSetterSupported) {
> 				obj[key] = obj[key];
> 				Object.defineProperty(obj, key, {
> 				    get : getter,
> 				    set : setter
> 				});
> 			}
> 			else if (obj.__defineGetter__) {
> 				obj.__defineGetter__(key, getter);
> 				obj.__defineSetter__(key, setter);
> 			}
> 			else {
> 				obj[key] == undefined && (obj[key] = valueStorage[key]);
> 			}
> 		};
> 	}
> 	var classDependent = {};
> 	// Call all callbacks after a class get ready so that dependent can
> 	// complete.
> 	function iamready( id, obj ) {
> 		if (classDependent[id]) {
> 			for ( var k = 0, len = classDependent[id].length; k < len; k++) {
> 				classDependent[id][k](id, obj);
> 			}
> 		}
> 		classDependent[id] = {
> 			classObj : obj
> 		};
> 	}
> 
> 	fm.getMissingClass = function(){
> 		var arr = [];
> 		for(var k in classDependent){
> 			if(!classDependent[k].classObj && !fm.isExist(k)){
> 			   arr.push(k); 
> 			}
> 		}
> 		return arr;
> 	};
> 
> 	// Store all callbacks dependent on class with name {id}.
> 	function onFileReady( id, cb ) {
> 		classDependent[id] = classDependent[id] || [];
> 		classDependent[id].push(cb);
> 	}
> 
> 	// return clas if class with name {id} is ready.
> 	function isReady( id ) {
> 		return classDependent[id];
> 	}
> 
203c354
< 			newImports[splited[splited.length - 1]] = window.fm.stringToObject(imp[k]);
---
> 			newImports[splited[splited.length - 1]] = fm.stringToObject(imp[k]);
208c359
< 	
---
> 
211c362
< 		
---
> 
219c370
< 	
---
> 
222c373
< 		
---
> 
230a382
> 
232c384,394
< 	
---
> 
> 	// Return whether object is empty.
> 	function isNotAEmptyObject( obj ) {
> 		for ( var k in obj) {
> 			if (obj.hasOwnProperty(k)) {
> 				return true;
> 			}
> 		}
> 		return false;
> 	}
> 
242c404
< 	
---
> 
253c415
< 	
---
> 
271c433,450
< 	
---
> 
> 	// add all transient fields to list.
> 	function addTransient( internalObj, tempObj ) {
> 		var temp = {}, k, tr = tempObj["transient"] || [];
> 		tr.push("shortHand");
> 		for (k = 0; k < tr.length; k++) {
> 			(temp[tr[k]] = true);
> 		}
> 		eachPropertyOf(internalObj.Static, function( v, key ) {
> 			temp[key] = true;
> 		});
> 		eachPropertyOf(internalObj.staticConst, function( v, key ) {
> 			temp[key] = true;
> 		});
> 		internalObj["transient"] = temp;
> 		internalObj = tempObj = k = temp = undefined;
> 	}
> 
279c458
< 	
---
> 
281c460
< 		
---
> 
298c477
< 				
---
> 
305,307c484,486
< 			
< 			eachPropertyOf(pofn.prototype.$get('fields'), function( v, k ) {
< 				pofn.prototype.$add(pofnS, k, v, true, true);
---
> 
> 			eachPropertyOf(pofn.prototype.$get('fields'), function( v, key ) {
> 				pofn.prototype.$add(pofnS, key, v, true, true);
311,312c490
< 	window.me = window.base = undefined;
< 	
---
> 
316,318c494,495
< 			var temp = fun.apply(context, arguments);
< 			bc && (temp = bc());
< 			return temp;
---
> 			fun.apply(context, arguments);
> 			bc();
321c498
< 	
---
> 
324c501
< 			window.fm.stackTrace("Class does not have any constructor ");
---
> 			fm.stackTrace("Class does not have any constructor ");
327c504
< 	
---
> 
331,333c508,510
< 		var name = str.substring(1 + indx);
< 		if (o[name]) {
< 			console.error("Short hand " + str + " for " + protoClass + " has conflict with. " + o[name]);
---
> 		var nam = str.substring(1 + indx);
> 		if (o[nam] && o[nam] != protoClass){
> 			//console.error("Short hand " + str + " for " + protoClass + " has conflict with. " + o[nam]);
335c512
< 		o[name] = protoClass;
---
> 		o[nam] = protoClass;
337c514
< 	
---
> 
339c516,541
< 	
---
> 	function addImportsOnready( implist, cb, fn ) {
> 		var counter = 0, complete;
> 		function decreaseCounter( ) {
> 			counter--;
> 			if (counter == 0 && complete) {
> 				cb();
> 			}
> 		}
> 		for ( var k = 0; implist && k < implist.length; k++) {
> 			counter++;
> 			var Class = isReady(implist[k]);
> 			if (Class && 'classObj' in Class) {
> 				decreaseCounter();
> 			}
> 			else {
> 				onFileReady(implist[k], function( obj, id ) {
> 					decreaseCounter();
> 				});
> 			}
> 		}
> 		complete = true;
> 		if (counter == 0) {
> 			cb();
> 		}
> 	}
> 
376c578
< 		
---
> 
392c594
< 	
---
> 
397c599
< 	
---
> 
407c609
< 	
---
> 
412c614
< 			
---
> 
427c629
< 			
---
> 
434,436c636,650
< 			
< 			obj.__defineGetter__(key, getter);
< 			obj.__defineSetter__(key, setter);
---
> 
> 			if (Object.defineProperty && isGetterSetterSupported) {
> 				obj[key] = obj[key];
> 				Object.defineProperty(obj, key, {
> 				    get : getter,
> 				    set : setter
> 				});
> 			}
> 			else if (obj.__defineGetter__) {
> 				obj.__defineGetter__(key, getter);
> 				obj.__defineSetter__(key, setter);
> 			}
> 			else {
> 				currentObj[key] != undefined && (obj[key] = currentObj[key]);
> 			}
439c653
< 	
---
> 
441a656
> 		// Return function name.
455c670
< 		
---
> 
489c704
< 		
---
> 
501c716,741
< 	
---
> 
> 	function invoke (fn, args, base, ics) {
> 
> 		var newObj = {};
> 		newObj.base = base;
> 		for (var i in ics) {
> 			 newObj[i] = ics[i];
> 		}
> 
> 		switch(args.length){
> 			case  0: return new fn();
> 	        case  1: return new fn(newObj[args[0]]);
> 	        case  2: return new fn(newObj[args[0]], newObj[args[1]]);
> 	        case  3: return new fn(newObj[args[0]], newObj[args[1]], newObj[args[2]]);
> 	        case  4: return new fn(newObj[args[0]], newObj[args[1]], newObj[args[2]], newObj[args[3]]);
> 	        case  5: return new fn(newObj[args[0]], newObj[args[1]], newObj[args[2]], newObj[args[3]], newObj[args[4]]);
> 	        case  6: return new fn(newObj[args[0]], newObj[args[1]], newObj[args[2]], newObj[args[3]], newObj[args[4]], newObj[args[5]]);
> 	        case  7: return new fn(newObj[args[0]], newObj[args[1]], newObj[args[2]], newObj[args[3]], newObj[args[4]], newObj[args[5]], newObj[args[6]]);
> 	        case  8: return new fn(newObj[args[0]], newObj[args[1]], newObj[args[2]], newObj[args[3]], newObj[args[4]], newObj[args[5]], newObj[args[6]], newObj[args[7]]);
> 	        case  9: return new fn(newObj[args[0]], newObj[args[1]], newObj[args[2]], newObj[args[3]], newObj[args[4]], newObj[args[5]], newObj[args[6]], newObj[args[7]], newObj[args[8]]);
> 	        case 10: return new fn(newObj[args[0]], newObj[args[1]], newObj[args[2]], newObj[args[3]], newObj[args[4]], newObj[args[5]], newObj[args[6]], newObj[args[7]], newObj[args[8]], newObj[args[9]]);
> 	        case 11: return new fn(newObj[args[0]], newObj[args[1]], newObj[args[2]], newObj[args[3]], newObj[args[4]], newObj[args[5]], newObj[args[6]], newObj[args[7]], newObj[args[8]], newObj[args[9]], newObj[args[10]]);
> 	        default: return new fn(newObj[args[0]], newObj[args[1]], newObj[args[2]], newObj[args[3]], newObj[args[4]], newObj[args[5]], newObj[args[6]], newObj[args[7]], newObj[args[8]], newObj[args[9]],
> 	                               newObj[args[10]], newObj[args[11]],newObj[args[12]],newObj[args[13]],newObj[args[14]],newObj[args[15]],newObj[args[16]],newObj[args[17]],newObj[args[18]], newObj[args[19]], newObj[args[20]]);
> 		}
> 	}
515d754
< 	
518c757
< 		
---
> 		/// this is script
521c760,761
< 		eval("tempObj= new Class(" + createArgumentString(pofn.base, pofn.ics) + ");");
---
> 		tempObj = invoke(Class, this.args, pofn.base, this.ics);
> 
524c764,765
< 		this.shortHand = tempObj.shortHand;
---
> 		this.shortHand = tempObj.shortHand || this.shortHand;
> 
527c768
< 		
---
> 
535c776
< 		
---
> 
542,543c783,784
< 		
< 		if (tempObj.init)
---
> 
> 		if (tempObj.init){
544a786
> 		}
552a795
> 		addTransient(this, tempObj);
556d798
< 		return this;
558c800
< 	
---
> 
561d802
< 		
566c807
< 	
---
> 
580c821,826
< 	
---
> //copy from angularjs
> 	var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
> 	var FN_ARG_SPLIT = /,/;
> 	var FN_ARG = /^\s*(_?)(.+?)\1\s*$/;
> 	var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
> 
586d831
< 		
589d833
< 		
591c835,836
< 		eval("currentObj= new Class(" + createArgumentStringObj(baseObj, pofn.ics) + ");");
---
> 		//var argArr = getArgsArray(this.args, baseObj, pofn.ics);
> 		currentObj = invoke(Class, script.args, baseObj, script.ics);
594d838
< 		//
595a840
> 		delete currentObj["transient"];
605a851
> 
608c854
< 	
---
> 
615c861,903
< 	
---
> 
> 	function getAllArgsSequence(fn){
> 		var arr = [];
> 		var args = fn.toString().replace(STRIP_COMMENTS, '').match(FN_ARGS);
> 		$.each(args[1].split(FN_ARG_SPLIT), function(i, arg){
> 	        arg.replace(FN_ARG, function(all, underscore, name){
> 	          arr.push(name);
> 	        });
> 	    });
> 		return arr;
> 	}
> 
> 	function Serialize(obj){
> 		var obj = obj || this;
>      	var newObj = jQuery.isArray(obj) ? [] :{};
>      	var transientArray = obj.transient || [];
>      	transientArray.push("transient", 'base');
>      	Array.prototype.push.apply(transientArray, fm.globaltransient);
>      	if(obj.beforeSerialize){
>      		obj.beforeSerialize();
>      	}
> 	     for(var k in obj){
> 	        if( k == 'error' && obj[k] ){
> 	            throw "Please fix error";
> 	        }
> 	        if(obj.hasOwnProperty(k) && transientArray.indexOf(k) == -1 && obj[k] != null){
> 	            if( typeof obj[k] == "object") {
> 	                newObj[k] = obj[k].instanceOf && obj[k].getClass ? obj[k].serialize() :Serialize(obj[k]);
> 	            }
> 	            else if(typeof obj[k] == "function" || typeof obj[k] == "undefined"){
> 
> 	            }
> 	            else{
> 	                newObj[k] = obj[k];
> 	            }
> 	        }
> 	     }
> 	     if(obj.afterSerialize){
>      		obj.afterSerialize();
>      	}
> 	     return newObj;
> 	}
> 
617,619c905,906
< 	function executeOnready( script, fn, Class ) {
< 		
< 		var internalObj = script;
---
> 	function executeOnready( script, fn, Class, data ) {
> 
629,633c916,924
< 		
< 		this.hashCode = getHashCode();
< 		
< 		script.baseClass && (this.base = window.fm.stringToObject(script.baseClass));
< 		
---
> 		if(script.baseClass){
> 			this.base = fm.stringToObject(script.baseClass);
> 			this.prototype.getSub = function( ) {
> 				return self;
> 			};
> 		}
> 
> 		this.serialize = Serialize;
> 
635,638c926,932
< 		this.ics = getAllImportClass(script.imports);
< 		getReleventClassInfo.call(internalObj, Class, fn, this);
< 		typeof internalObj.shortHand == 'string' && addShortHand(internalObj.shortHand, this);
< 		this.isAbstract = internalObj.isAbstract;
---
> 		script.ics = getAllImportClass(script.imports);
> 		script.args = getAllArgsSequence(Class);
> 
> 		getReleventClassInfo.call(script, Class, fn, this);
> 
> 		typeof script.shortHand == 'string' && addShortHand(script.shortHand, this);
> 		this.isAbstract = script.isAbstract;
644c938
< 			return internalObj[key];
---
> 			return script[key];
646c940
< 		
---
> 
648,649c942
< 		
< 		Class.prototype = this;
---
> 
665c958,969
< 		this.constructor = defaultConstrct;
---
> 
> 		if(data && typeof data[data.length -1] == 'function'){
> 			data.pop()();
> 		}
> 
> 		var obj ={};
> 		for (var i in this) {
> 			obj[i]=this[i];
> 		};
> 		obj.prototype = this.prototype;
> 		Class.prototype = obj;
> 		iamready(this.getClass(), this);
667c971
< 			this.main();
---
> 			this.main(data);
670c974
< 		return;
---
> 		data = undefined;
672c976
< 	
---
> 
694c998
< 	
---
> 
706,708c1010,1012
< 	
< 	function classManager( script ) {
< 		
---
> 
> 	function classManager( script, data, older ) {
> 
710a1015,1019
> 			console.log("Either Package or Class name is missing");
> 			return;
> 		}
> 		if(typeof(older) == 'function' ){
> 			po[fn] = older;
712a1022
> 
713a1024
> 			script.shortHand = fn;
714a1026
> 				window[fn] = null;
720a1033
> 		//Storing Original Class in Class;
722c1035,1036
< 		po[fn] = function manager( ) {
---
> 		//Creating new object which is temporary
> 		po[fn] = function ( ) {
724d1037
< 			
735c1048,1052
< 		executeOnready.call(po[fn], script, fn, Class);
---
> 		// Add resource ready queue.
> 		addImportsOnready(script.imports, function( ) {
> 			executeOnready.call(po[fn], script, fn, Class, data);
> 			data = undefined;
> 		}, fn);
737,739c1054
< })(global);
< 
< 
---
> })(window);
740a1056
> fm.basedir = "/js";
\ No newline at end of file
