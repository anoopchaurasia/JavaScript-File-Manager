<div style="padding: 10px;  "><div id="Static" style=" "><b style=" ">What is Static</b><br>Static keyword is like any other keyword a
        simple keyword which can be applied to method , nested class or member variable inside a class. <b>When we make a variable static
            it means it belongs to that particular class instead of object</b>, remember class is a blueprint while objects are real
            instances. So a static variable will always hold same value for all instances of that class. In other words there is only
            one copy of static keyword will be present in memory which can be accessed or altered by any object. When we make a method
            static means that method belongs to class and you can call it without creating instance of that class. mostly utility
            methods are declared as static to call them directly by using class name and not to wait for object to be ready.<br>Note:
            All methods/Fields starting with Static are public. Private Static is not supported yet.<br></div><br><div id="Const"><b>Const</b><br>
                Define an entity once that cannot be changed nor derived from later. More specifically: a final variable can occur at most 
                once as a left-hand expression.<br>Note:Const method and class are not supported.<br></div><br><br><div id="Private" style=" "><b>
                        Private Constructor</b><br>A private constructor prevents external instantiation of its containing class and sub classing.
                        Objects can be created. But the creation is done internally.<br></div><br><div id="AbstractClass" style=" "><b>Abstract
                                Methods and Classes</b><br>An abstract class is a class that is declared abstract?it may or may not include 
                                abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.<br>An abstract method
                                is a method which start with Abstract.<br>Abstract.moveTo = function(){};<br>If a class includes abstract methods, 
                                the class itself must be declared abstract, as in:<br>AbstractClass("GraphicObject");<br>GraphicObject = 
                                function() {<br>&nbsp; &nbsp;// declare fields<br>&nbsp; &nbsp;// declare non-abstract methods<br>&nbsp;
                                &nbsp;Abstract.draw = function(){};<br>}<br>When an abstract class is subclassed, the subclass usually 
                                provides implementations for all of the abstract methods in its parent class. However, if it does not, 
                                the subclass must also be declared abstract.<br></div><br><div id="code"><pre style=" "><code style=" "><br>
fm.Package("com.test");<br>fm.Import("jfm.util.HashMap");<br>fm.Import("jfm.lang.Integer");<br>fm.Import("jfm.io.Serialize");<br>
fm.Implements("jfm.io.Serializable");<br>fm.Class("Home", "com.test.HomeBaseClass");<br>Home = function () {<br> var singleton;<br> 
Static.Const.field1 = "A String";<br> this.hashMap = new HashMap("a1", new Integer(4));<br> this.intger = new Integer(56);<br>
 Const.Static.filed2= 1234;<br> Static.getInstance = function () {<br> if (!singleton) {<br> singleton = new me();<br> }<br> 
return singleton;<br> };<br> this.publicMethod = function(){<br> /// implement<br> }<br> function localMethod(){<br> //<br>
 me.publicMethod();<br> if(base.publicMethod){<br> base.publicMethod();<br> }<br> }<br> Static.staticMethod = function(){<br>
 //here keyword this belong to class not any instance<br>};<br> this.start = function(){<br> return base.start();<br> };<br>
 <br> this.setSerializable = function(obj){<br> this.hashMap.setSerializable(obj.hashMap);<br> this.intger.setSerializable(obj.integer);<br> };<br>
 <br> this.getSerializable = function(){<br> return obj = {<br> hashMap : this.hashMap,<br> integer : this.intger<br> };<br> };<br> <br>
 Private.Home = function () {<br> this.hashMap.put("key1", new Integer(2));<br> this.hashMap.put("key2", new Integer(2))<br>base( 
this.getFunctionName() +" called from " + arguments[0] );<br> };<br>};<br></code><br></pre><br></div><br></div>